---
title: "Data transformation"
subtitle: dplyr
author: "A. Ginolhac, E. Koncina, R. Krause"
date: "2 May 2017"
output:
  iosp::ioslides_plus:
    footer: "[R tidyverse workshop](https://lsru.github.io/tv_course/)"
    box_colours:
      bg-my_colour: "slateblue2"
      yellow2: ["lightgoldenrod1", "goldenrod2"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.align = "center")
# Do not use cache = TRUE with _site.yml! They do not like each other...
```

## Data transformation | Introduction

 * Preparing data is the most time consuming part of of data analysis  
 
### `dplyr` in a nutshell {.box-8 .bg-yellow2 .build .stretch}
 * `dplyr` is a tool box for working with data in tibbles/data frames
 * The most import data manipulation operations are covered
     + Selection and manipulation of observation, variables and values 
     + Summarizing
     + Grouping
     + Joining and intersecting tibbles
  * In a workflow typically follows reshaping operations from `tidyr`
  * Fast, in particular for in-memory data by writing key pieces in C++ (using Rcpp)
  * Standard  interface to work with data in a `data.frame`, a `data.table` or database.


## dplyr | Introduction: [Cheat sheets](https://www.rstudio.com/resources/cheatsheets/)

```{r, echo=FALSE, out.width = '90%'}
knitr::include_graphics("img/06_dplyr_cheatsheet.png")
```

## dplyr | Introduction: [Cheat sheets](https://www.rstudio.com/resources/cheatsheets/) (cont.)

```{r, echo=FALSE, out.width = '90%'}
knitr::include_graphics("img/06_dplyr_cheatsheet_p2.png")
```



## Installation

```{r, include=FALSE}
library("tidyverse")
library("biomaRt")

```

- `dplyr` is included in the `tidyverse` package

```{r, eval = FALSE}
install.packages("dplyr")
# OR
install.packages("tidyverse")

library("dplyr")
```

- For the examples in the lecture, retrieve the genes from chromosome 21 from biomaRt

```{r, eval = T, cache=T}
# Load the library
library(biomaRt)
gene_mart <- useMart(biomart="ENSEMBL_MART_ENSEMBL", host="www.ensembl.org")
gene_set <- useDataset(gene_mart , dataset="hsapiens_gene_ensembl")


gene_ids <- getBM(mart=gene_set, attributes
                 =c( "ensembl_gene_id",
                      "ensembl_peptide_id", 
                     "ensembl_exon_id",
        "chromosome_name",
         "start_position",
           "end_position",
        "hgnc_symbol", "hgnc_id", 
        "strand",
        "gene_biotype"), 
                 filter = "chromosome_name", value="21")




#Biomart
```

- Or use `Rstudio > Tools > Install` Packages to install the packages



```{r}
as.tibble(gene_ids)
```

## Inspect data frames / tibbles | glimpse  

Use `glimpse` to show some values and types per column. Environment tab does it too

```{r}
glimpse(gene_ids)
```


## Pipes in R | magrittr

```{r, echo=FALSE, out.width = '70%'}
knitr::include_graphics("img/05_piping.png")
```

from [Romain FranÃ§ois](https://twitter.com/ParisRaddict/status/781267225420435461)



## `filter()` | inspect subsets of data

- Take a look at the amyloid precursor protein gene **APP** 

```{r}
gene_ids %>%
  filter(hgnc_symbol == "APP")
```

## filter | multiple conditions, AND (`&`)



```{r}
# Comma separated conditions are combined with '&'
gene_ids %>%
  filter(start_position > 1000000, end_position < 10000000)
```


## filter | multiple conditions, OR (`|`)

Genes at the close to the end 

```{r, eval = FALSE}
gene_ids %>%
  filter(start_position < 100000 | end_position >46655124 )
```

For more complicated checks, prefer a set operation.  
The following 2 are equivalent:

```{r, eval = FALSE}
gene_ids %>%
  filter(is.element(hgnc_symbol, c("APP", "ATP50", "PRMT2")))
```

```{r, eval = FALSE}
gene_ids %>%
  filter(is.element %in% c("APP", "ATP50", "PRMT2"))
```

## arrange | sort columns

### Perform a nested sorting of all Genes: {.box-6 .bg-yellow2 .build}
    1. hgnc_symbol
    2. gene_biotype
    3. end_position

%end%

```{r}
gene_ids %>%
  arrange(hgnc_symbol, gene_biotype, end_position)
```

## arrange | `desc` to reverse sort columns

Find the *last* gene on chromosome 21.

```{r}
gene_ids %>%
  arrange(desc(end_position)) %>%
  dplyr::select(end_position, everything()) # way to reorder arr_delay 1st column
```

## select | selecting specific columns

```{r}
gene_ids %>%
  dplyr::select(hgnc_symbol, chromosome_name, start_position, end_position)
```

## select | helper functions

`select` has many helper functions. See `?select` or have a look at the cheatsheet.

```{r}
gene_ids %>%
  dplyr::select(hgnc_symbol, starts_with("ensembl"), contains("position"))
```

## negative selection 

### {.box-10 .offset-1 .bg-blue}
We can drop columns by "negating" their names. Since helpers give us column names, we can negate them too. Note that the 

```{r}
gene_ids %>%
  dplyr::select(-strand, -starts_with("ensembl"),
         -ends_with("id"))
```

## Recap: Verbs for inspecting data

* `as_tibble` (`dplyr::as_data_frame`) to convert to a tibble (different from `as.data.frame` in _R_ base)
* `glimpse` - some of each column
* `filter` - subsetting
* `arrange` - sorting (`desc` to reverse the sort)
* `select` - picking (and omiting) columns

## rename | renaming columns

- Rename columns with `rename(new_name = old_name)`.
    + To keep the order correct, read/remember the renaming `=` as "was".
    + Rename will replace column names (see `mutate(new_name = old_name)` for simple copy  )

```{r}
gene_ids %>%
  rename(stop = end_position, start = start_position)
```

## mutate | add or replace columns{.build}


- How long is your gene
- Note that new variables can be used right away

```{r}
gene_ids %>%
  filter(gene_biotype =="protein_coding") %>% 
  mutate(  length = end_position - start_position) %>% 
  dplyr::select(hgnc_symbol, length)
```


### Not quite right
```{r}
gene_ids %>%
  filter(gene_biotype =="protein_coding") %>% 
  mutate(  length = end_position - start_position) %>% 
  dplyr::select(hgnc_symbol, length) %>% 
  distinct()
```

## Grouping | `group_by()`

 * Not a summarising transformation but frequently used in conjunction 
 * Grouping by more than one or more variables
 * Use `ungroup()` 

## group_by | Grouping

- Let's compute the average number of exons 

```{r}
gene_ids %>%
  group_by(gene_biotype) %>%
   mutate(  length = end_position - start_position) %>% 
    #Some values are missing, thus tell `mean` to remove them from the calculation.
  summarise(by_type_length = floor(mean(length, na.rm = TRUE))) %>% 
  arrange(desc(by_type_length))
```


## group_by | Grouping

- Number of exons

```{r}
gene_ids %>%
  group_by(ensembl_gene_id, hgnc_symbol) %>% 
  summarise(nexon =n_distinct(ensembl_exon_id))

```



## Exercise{.build .exercise}

- In average, how many gene_ids is a single plane doing per day?

- Calculate the average delay per day.

- Which day should be avoided?

## Solution | 1. single plane gene_ids per day

```{r eval=FALSE}
by_day %>%
  summarise(gene_ids = n(),
            avg_delay = mean(dep_delay, na.rm = TRUE),
            n_planes = n_distinct(tailnum)) %>%
  mutate(avg_gene_ids = gene_ids / n_planes)
```

## Solution | 2. distribution of single plane gene_ids per day

```{r, fig.height = 4, eval = FALSE}
by_day %>%
  summarise(gene_ids = n(),
            avg_delay = mean(dep_delay, na.rm = TRUE),
            n_planes = n_distinct(tailnum)) %>%
  mutate(avg_gene_ids = gene_ids / n_planes)
```

## Solution | 3. average delay per day

```{r, fig.height = 4, fig.width = 10, eval = FALSE}
by_day %>%
  summarise(avg_delay = mean(dep_delay, na.rm = TRUE)) %>%
  unite(date, year, month, day, sep = "-") %>%
  mutate(date = as.Date(date)) %>%
  ggplot() + 
  geom_bar(aes(x = date, y = avg_delay), stat = "identity")
```

## Solution | 4. day to avoid

```{r eval=FALSE}
by_day %>%
  summarise(avg_delay = mean(dep_delay, na.rm = TRUE)) %>%
  arrange(desc(avg_delay))
```

## Exercise{.exercise}

- Find the destinations with the highest average arrival delay?
  + discard gene_ids with missing data as arrival delay
  + count the number of gene_ids per destination
  + discard results with less than 10 gene_ids, mean not meaningful

## Solution | destinations with highest average arrival delay

```{r eval=FALSE}
gene_ids %>%
  filter(!is.na(arr_delay)) %>%
  group_by(dest) %>%
  summarise(mean = mean(arr_delay),
            n = n()) %>%
  filter(n > 10) %>%
  arrange(desc(mean))
  
```

## Other biomaRt data

Get homologs
```{r eval=FALSE}
airports
```

## Join two data frames

```{r eval=FALSE}
delays <- gene_ids %>%
  filter(!is.na(arr_delay)) %>%
  group_by(dest) %>%
  summarise(mean = mean(arr_delay),
            n = n()) %>%
  filter(n > 10) %>%
  arrange(desc(mean)) %>%
  inner_join(airports, by = c("dest" = "faa")) # provide the equivalence since columns have a different name
```

We could have used **left_join** but 4 rows with a 3-letters acronym have no correspondance in the `airports` data frame. **inner_join** narrows down the lines that are present in both data frames.

## Join types

```{r, echo = FALSE}
knitr::include_graphics("http://www.dofactory.com/Images/sql-joins.png")
```

Of note: **anti_join** can select rows which identifiers are **absent** in the second data frame.


## Join as data frames | **mutating** joins

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics("img/05_joins.png")
```

credit: [Hadley Wickham, R for data science](http://r4ds.had.co.nz/relational-data.html)

## Join as data frames | **filtering** joins

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics("img/05_filtering-joins.png")
```

credit: [Hadley Wickham, R for data science](http://r4ds.had.co.nz/relational-data.html)




## tally / count

`tally` is a shortcut to counting the number of items per group.

```{r}
gene_ids %>%
  group_by(hgnc_symbol) %>%
  tally() %>% head(3) # could sum up with multiple tally calls
```
`count` does the grouping for you
```{r}
gene_ids %>%
  count(hgnc_symbol) %>% head(3)
```


## `lead() and lag()` | Comparing rows above and below

### Calculate intergenic distance {.box-8 .offset-1, .bg-blue}
<!~- Common issue solved by self-joins or for loops-->
```{r}
gene_ids %>%
  dplyr::select(ensembl_gene_id, start_position, end_position) %>% 
  distinct() %>% 
  arrange(start_position) %>% 
  mutate(intergenic_length = start_position - lag(end_position)) 
```


## That covers 80% of dplyr


- select
- filter
- arrange
- glimpse
- rename
- mutate
- group_by, ungroup
- summarise

## Other 20%


- assembly: `bind_rows`, `bind_cols`
- windows function, `min_rank`, `dense_rank`, `cumsum`. See [vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html)
- column-wise operations: `mutate_each`, `transmute`, `summarise_each`
- column-wise conditional operations: `mutate_at`, `mutate_if`, `summarise_at`, `summarise_if`
- `do`: arbitrary code on each chunk. To be replaced by `tidyr::nest() %>% mutate(purrr::map())`
 `data.tables`)

## `dplyr 0.6` | Forthcoming changes

## Missing features
parallel dplyr
dbplyr -- databases access

## Data base access
 - `dplyr` code can be translated into SQL and query databases online
 - different types of tabular data ([dplyr SQL backend](https://cran.r-project.org/web/packages/dplyr/vignettes/databases.html), databases,

## Bigger data, go for `data.table`

### {.box-10 .offset-1 .bg-blue .icon}

 + See this interesting [thread](http://stackoverflow.com/questions/21435339/data-table-vs-dplyr-can-one-do-something-well-the-other-cant-or-does-poorly) about comparing `data.table` versus `dplyr` 
 + [`data.table`](https://cran.r-project.org/web/packages/data.table/index.html), see  [introduction](https://github.com/Rdatatable/data.table/wiki) is very efficient but the syntax is not so easy.
 + Main advantage: inline replacement (tidyverse is frequently copying)
 + As a summary:      _tl;dr   data.table for speed, dplyr for readability and convenience_ [Prashanth Sriram](https://www.quora.com/Which-is-better-to-use-for-data-manipulation-dplyr-package-or-data-table-library)
  + Hadley recommends that for data > 1-2 Gb, if speed is your main matter, go for `data.table` 
  + `dtplyr` is a `dplyr` interface to `data.table` but slower than native `data.table`

![](https://www.stickermule.com/marketplace/embed_img/16249 )
