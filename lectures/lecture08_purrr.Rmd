---
title: "Data processing with R tidyverse"
subtitle: "_purrr_"
author: "A. Ginolhac, E. Koncina, R. Krause"
date: "4 May 2017"
output:
  iosp::ioslides_plus:
    box_colours:
      bg-yellow: ["lightgoldenrod1", "goldenrod2"]
      bg-grayblue: ["#bfccd7"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = "center")
ggplot2::theme_set(ggplot2::theme_bw(14))
library(tidyverse)
```

## Reminder | Lists and vectors

### Atomic vectors{.box-6 .bg-blue}

Each **atomic** vector contains only a single type of data

- The type of each atom is the same
- The size of each atom is 1 (single element)
- Examples:
    ```{r, eval = FALSE}
    # Logical
    c(TRUE, FALSE, TRUE)
    
    # double
    c(1, 5, 7)
    
    # character
    c("character", "sequence")
    ```

### Coercion{.box-6 .bg-blue}

Is the conversion between types

- can be **explicit** using `as.*()` functions

```{r}
v_example <- c(1, 3, 7)
str(as.character(v_example))
```

- can be **automatic**

```{r}
v_example <- c(1, 3)
str(v_example)
str(c(v_example, "seven"))
```


## Reminder | Lists and vectors

### Lists{.box-6 .bg-blue}

- are **vectors** which are **not atomic**.
  + Elements can be of different types
  + The length of each element (atom) might be greater than 1.
- example
    ```{r}
    my_list <- list(1, 3, "seven")
    str(my_list)
    is.vector(my_list)
    is.atomic(my_list)
    ```

## Purrr | functional programming

```{css}
.icon img {
  float: right;
  margin-left: 20px;
}

.center-pic img {
  display: block;
  margin: auto;
  margin-top: 5px;
  margin-bottom:5px;
}

.center-pic .caption {
  text-align: center;
}

.compact-pre pre:not(.lang-r) {
  line-height: 15px;
}

.small img {
  max-height: 64px;
}

.box > h3:first-child > code {
  background-color: rgba(250, 250, 250, 0.5);
}
```

### Overview {.box-8 .offset-2 .bg-blue .icon}

![](img/08_purrr.png)

purrr enhances R's **functional programming** toolkit by providing a complete and consistent set of tools for **working with functions and vectors** (purrr overview on github page)

### {.col-10 .offset-1 .build}

> **functional programming** is a programming paradigm -- a style of building the structure and elements of computer programs -- that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data | Wikipedia{.bg-red}

## Purrr | focuses on functions

### functional programming features{.box-6 .bg-blue}

- pass functions as arguments to other functions
- code that does not change state (a same call should yield the same result)

### Iteration {.box-6 .bg-red .icon}

FOR EACH `x` DO `f`

### Example {.box-12 .bg-green .compact-pre}

Calculate the mean of each column of the mtcars dataset

```{css}
.col-h250 {
  max-height: 260px;
  overflow: hidden;
  padding-top: 0;
}
```

<div class = "row"><div class = "col-6 col-h250 build">

### `for` loops

```{r}
means <- vector("double", ncol(mtcars))
for (i in seq_along(mtcars)) {
  means[i] <- mean(mtcars[[i]])
}
means
```

</div><div class = "col-6 col-h250 build">

### base R apply family

```{css}
/* Adapted from http://stackoverflow.com/a/34754719 */
table,
.table-condensed,
table.rmdtable {
  width: auto;
  margin-left: auto;
  margin-right: auto;
}
table,
.table-condensed,
table.rmdtable,
table.rmdtable .header th,
.table > thead > tr > th {
  border-collapse: collapse;
  border-style: solid;
  border-spacing: 0;
  border-width: medium 0 medium 0;
  border-color: inherit
}
table.rmdtable th,
table.rmdtable td,
table th,
table.rmdtable tr > td:first-child,
table.rmdtable .even {
  font-size: 100%;
  padding: 0.4em 0.5em;
  color: inherit;
  background: #adebad;
  font-weight: normal;
}
.table > tbody > tr > td {
  border-width: 0;
}
```

```{r}
apply(mtcars, 2, mean) %>% str()
lapply(mtcars, mean) %>% str()
```

</div></div>

## apply vs map

### The apply family of functions{.box-6 .bg-green}

-------------------------------  ---------  -------------------------------
 function                          input                 output
-------------------------------  ---------  -------------------------------
 `apply()`                          array      vector or array or list

 `lapply()`                         list       list

 `sapply()`                         list       vector or array or list
 
 `vapply()`                         list       specified but inconsistent
-------------------------------  ---------  ------------------------------

### Warning {.box-6 .bg-red}

- Most members of the `apply()` family are inconsistent.
- Exception: `vapply()`
- `apply()` family still usefull to avoid dependencies (package development)

### The `purrr::map()` family of functions {.box-8 .offset-2 .bg-blue}

- are designed to be consistent
- `map()` is the general function and close to `base::lapply()`
- `map()` introduces shortcuts (absent in `lapply()`)
- six variants to specify the type of vectorized output (`map_lgl()`, `map_int()`, `map_dbl()`, `map_chr()`, `map_df()`, `walk()`)


## `Purrr::map()`

### Illustration {.box-12 .bg-blue .center-pic}

- `purrr::map()` is **type stable**
    + applies a function to each element of a list
    + returns a list
    + `map(YOUR_LIST, YOUR_FUNCTION)`

```{r, eval = FALSE}
antennate <- function(x) put_on(x, antenna)
map(legos, antennate)
```

<div class = "row build"><div class = "col-5">

![legos](img/08_lego.jpg)

</div><div class = "col-2">

![antenna](img/08_lego_antenna.jpg)

</div><div class = "col-5">

![`map(legos, antennate)`](img/08_lego_antennate.jpg)

</div></div>

## Purrr | map shortcuts

### Example {.box-6 .bg-green}

- Split the mtcars dataset by each value of cylinder
    ```{r}
    spl_mtcars <- mtcars %>%
      split(.$cyl)
    str(spl_mtcars, max.level = 1)
    ``` 
- On each element (dataframe) of the list, we would like to:
    + fit a linear model (miles per gallon explained by the weight)
    + extract the $r^2$ value


## `purrr::map()` | example

### 1 - map the linear model {.box-6 .bg-green}

- reminder:
    ```{r, eval = FALSE}
    map(YOUR_LIST, YOUR_FUNCTION)
    # is equivalent to:
    YOUR_LIST %>% map(YOUR_FUNCTION)
    ```

- `YOUR_LIST` = `spl_mtcars`
- `YOUR_FUNCTION` can be an anonymous function (declared on the fly)

```{r}
str(spl_mtcars, max.level = 1)
```

### {.box-6 .compact-pre}

```{r}
spl_mtcars %>% 
  map(function(df) lm(mpg ~ wt, data = df))
```

## `purrr::map()` | example

### 2 - extract $r^2$ {.box-10 .offset-0 .bg-green}

- map uses a list as an argument and **returns a list**
- we can map a new function on the output of the previous call

### {.box-10 .offset-2 .compact-pre}

```{r}
spl_mtcars %>% 
  map(function(df) lm(mpg ~ wt, data = df)) %>%
  map(summary) %>%
  map(function(x) x$r.squared)
```

### Tip {.box-6 .offset-3 .bg-blue .vs1 .icon .small}

![](img/00_tip.png)

The code above can be simplified using shortcuts provided by `purrr`

## `purrr::map()` | shortcuts

- One sided formula to create anonymous functions (using `~` and the placeholder `.` which refers to the current list element)
    ```{r, eval = FALSE}
    map(YOUR_LIST, function(df) lm(mpg ~ wt, data = df))
    
    # is equivalent to:
    
    map(YOUR_LIST, ~ lm(mpg ~ wt, data = .))
    ``` 

Our previous code can be simplified:

### Initial code{.box-7 .bg-cobalt}

```{r, eval = FALSE}
spl_mtcars %>% 
  map(function(df) lm(mpg ~ wt, data = df)) %>%
  map(summary) %>%
  map(function(x) x$r.squared)
```

### Using shortcuts{.box-5 .bg-cobalt}

```{r, eval = FALSE}
spl_mtcars %>% 
  map(~lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map(~.$r.squared)
```

%end%

- Use a string to extract **named components**

### Using shortcuts{.box-5 .offset-7 .bg-cobalt}

```{r, eval = FALSE}
spl_mtcars %>% 
  map(~lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map("r.squared")
```


## The map function family

### Reminder {.box-6 .bg-blue}

- `purrr::map()` (like base `base::lapply()`)
    + uses a **list** as an input
    + outputs a **list**
    
### Choosing output type{.box-6 .bg-red}

- purrr provides a family of functions to generate specific outputs
    + `map()` makes a **list**.
    + `map_lgl()` makes a **logical** vector.
    + `map_int()` makes an **integer** vector.
    + `map_dbl()` makes a **double** vector.
    + `map_chr()` makes a **character** vector.

### using `map()`{} {.box-6 .bg-cobalt .compact-pre}

```{r, eval = TRUE}
spl_mtcars %>% 
  map(~lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map("r.squared") %>% 
  str()
```

### using `map_dbl()`{} {.box-6 .bg-cobalt .compact-pre}

```{r, eval = TRUE}
spl_mtcars %>% 
  map(~lm(mpg ~ wt, data = .)) %>%
  map(summary) %>%
  map_dbl("r.squared") %>% 
  str()
```


## Importing data

<!-- readxl example -->

<!-- importing several files -->

## Purrr | Iterating on 2 lists

### `map(legos, antennate)`{} {.box-6 .bg-red .center-pic}

![](img/08_lego.jpg)
![](img/08_lego_antenna.jpg)
![](img/08_lego_antennate.jpg)

```{r, eval = FALSE}
map(legos, antennate)
```

### `map2()`{} {.box-6 .bg-red .center-pic .stretch}

![](img/08_lego_hairs.jpg)
![](img/08_lego_enhaired.jpg)


```{r, eval = FALSE}
enhair <- function(x, y) x %>% put_on(y)
map2(legos, hairs, enhair)
```



## The tidyverse focuses on data frames

### pros {.box-6 .bg-green}

- easy
- works with `dplyr`
- nicely structured

### cons {.box-6 .bg-red .stretch}

- same length requirement
- atomic vectors

### solution {.box-8 .offset-2 .bg-yellow .icon .vs1}

![](https://raw.githubusercontent.com/tidyverse/tibble/master/man/figures/logo.png)

- **Use lists!** But inside the *tidyverse*
    + `tibble` introduces **list-columns**
    + works with `dplyr`
    + groups are respected
    + easily created with `tidyr::nest()`
    + perfect input for `purrr::map`

## Lists as a column in a tibble

### Example {.box-12 .offset-0 .bg-grayblue .icon}

![](img/08_lego_tibble.jpg)

```{r}
tibble(numbers = 1:8,
       my_list = list(a = c("a", "b"), b = 2.56, 
                      c = c("a", "b"), d = rep(TRUE, 4),
                      d = 2:3, e = 4:6, f = "Z", g = 1:4))
```

## Example

### Rewriting our previous example {.box-4 .bg-cobalt .build .stretch}

```{r, class = "build shadow"}
mtcars %>%
  group_by(cyl) %>%
  nest()
```

### Use mutate and map {.box-8 .bg-cobalt .build .stretch}

```{r, class = "build shadow"}
mtcars %>%
  group_by(cyl) %>%
  nest() %>%
  mutate(model = map(data, ~lm(mpg ~ wt, data = .)),
         summary = map(model, summary),
         r_squared = map_dbl(summary, "r.squared"))
```

###{.box-8 .offset-2 .bg-red .build}

- very powerful
- next lecture will show you how `dplyr`, `tidyr`, `tibble`, `purrr` and `broom` nicely work together

## Purrr | Pure functions

### {.col-6}

<blockquote class="twitter-tweet" data-lang="fr"><p lang="en" dir="ltr">Make your pure <a href="https://twitter.com/hashtag/rstats?src=hash">#rstats</a> functions purr with purrr, a new package for functional programming: <a href="http://t.co/91Efuz0txk">http://t.co/91Efuz0txk</a></p>&mdash; Hadley Wickham (@hadleywickham) <a href="https://twitter.com/hadleywickham/status/648959790056509440">29 septembre 2015</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

### {.col-6}

> A function is called "pure" if all its inputs are _declared_ as inputs - none of them are hidden - and likewise all its outputs are _declared_ as outputs | {.bg-blue}[Kris Jenkins](http://blog.jenkster.com/2015/12/what-is-functional-programming.html)

### Ressources:

- What is Functional Programming? by Kris Jenkins
    + [Blog version](http://blog.jenkster.com/2015/12/what-is-functional-programming.html)
    + [Talk video](https://www.youtube.com/watch?v=tQRtTSIpye4)

## Purrr | Pure functions

### Impure function {.box-6 .bg-green}

- has hidden inputs or outputs
- hidden inputs or outputs are called _**side-effects**_

```{r}
start <- 10

impure <- function(x) {
  print(start)
  x + start
}

result <- impure(2)

result
```


### Pure function {.box-6 .bg-green}

- no hidden inputs and/or outputs

```{r}
pure <- function(x, start) {
  x + start
}

result <- pure(2, start)
result
```

## Use `purrr` to purify functions

### Example{.box-12 .bg-green}

- Even `log()` has side-effects
- Use `purrr::safely()` to catch every output

### Impure `log()`{} {.box-6 .bg-cobalt .build .compact-pre}

```{r, error = TRUE}
(res <- log(10))
res <- log("a")
res
```

### Purified `log()`{} {.box-6 .bg-cobalt .compact-pre}

```{r}
safe_log <- purrr::safely(log)
(res <- safe_log(10))
res <- safe_log("a")
res
```

## Useful functions

Let's go further with the `safe_log()` example

###{.col-12 .compact-pre .build}

```{r, row = c(4, 8)}
# Example from the help page
x <- list("a", 1, 2)
y <- x %>% map(safely(log))
y %>% str()
```
###{.col-12 .compact-pre .build}

```{r, row = c(4, 8)}
y %>% transpose() %>% str()
```

## Before we stop

### Further reading {.box-10 .offset-1 .bg-blue .icon}

![](img/00_book.png)

- Jennifer Bryan [lessons & tutorial](https://jennybc.github.io/purrr-tutorial/)
- Hadley Wickham [R for data science, iteration](http://r4ds.had.co.nz/iteration.html)
- Hadley Wickham [R for data science, many models](http://r4ds.had.co.nz/many-models.html)
- Ian Lyttle [purrr applied for engineering](http://ijlyttle.github.io/isugg_purrr/presentation.html#%281%29)
- Robert Rudis [purrr, comparison with base](https://rud.is/b/2016/07/26/use-quick-formula-functions-in-purrrmap-base-vs-tidtyverse-idiom-comparisonsexamples/)
- Rstudio's blog [purrr 0.1 release](https://blog.rstudio.org/2015/09/29/purrr-0-1-0/)
- Rstudio's blog [purrr 0.2 release](https://blog.rstudio.org/2016/01/06/purrr-0-2-0/)

### Acknowledgments {.box-10 .offset-1 .vs1 .bg-yellow}

* Hadley Wickham
* Robert Rudis
* Jennifer Bryan ([LEGO pictures](https://github.com/jennybc/lego-rstats), courtesy CC licence)
* Ian Lyttle
* David Robinson
