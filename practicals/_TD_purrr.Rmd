---
title: "`purrr` practical"
author: "Eric Koncina"
date: "4 May 2017"
output:
  unilur::tutorial_html_solution: default
  unilur::tutorial_html: default
  unilur::tutorial_pdf: default
  unilur::tutorial_pdf_solution: default
---

```{r setup, include = FALSE}
library("tidyverse")
knitr::opts_chunk$set(message = FALSE)
```

## 1. The `iris` dataset

Calculate the number of unique values in each column of the `iris` dataset. (_from R for Data Science_)

```{r, solution = TRUE}
map_int(iris, ~ length(unique(.)))
```

## 2. Loading data

Download a set of qPCR experiments results [here](). The file is a zip archive which you should unzip into a suitable folder.

The results were obtained from 2 different samples and were replicated 5 times. The qPCR results are stored in 10 different files. A filename looks like "mlc1_1.csv" where the first number is the sample id and the second the replicate id.

### Read in the qPCR results

```{asis,  boxtitle = "Warning", box = "orange"}
Do not use `for` loops.
```

```{r, message = FALSE, solution = TRUE}
dir("data/pcr", full.names = TRUE) %>%
  set_names() %>%
  map_df(read_delim, delim = " ", .id = "filename") %>%
  mutate(id = stringr::str_extract(filename, "\\d_\\d")) %>%
  separate(id, c("sample_id", "replicate_id"), sep = "_")
```

## 3. Loading data and handling untidy data

Download the excel file called `sizes.xls`. The file contains the size measures of 5 different samples before and after a treatment. We would like to calculate the volume of the object before and after the treatment.

### Load the content of the excel file

First load the measures into a data frame using the powerful tools provided by the `purrr` package.

```{r, solution = TRUE}
library(readxl)

xls_file <- "data/sizes.xls"

excel_sheets(xls_file) %>%
  set_names() %>% 
  map_df(read_excel, path = xls_file, .id = "treatment_onset", range = "B3:C9")
```

### Calculate the volume

It turns out that the size ($width \times height \times depth$) was not entered in a tidy form. Extract the different values in order to calculate the volume.

```{asis,  boxtitle = "Warning", box = "orange"}
We already saw the `tidyr::separate` function which might help you to get what you want. Here we would like to stick to a `purrr` approach.
```
```{asis,  boxtitle = "Tip", box = "lightblue"}
You might want to use `base::strsplit()` or `stringr::str_split()` 
```

```{r, solution = TRUE}
# The tidyr / dplyr way but it's not a purrr approach
excel_sheets(xls_file) %>%
  set_names() %>% 
  map_df(read_excel, path = xls_file, .id = "treatment_onset", range = "B3:C9") %>% 
  separate(size, c("width", "height", "depth"), sep = "x") %>%
  mutate_at(c("width", "height", "depth"), parse_integer) %>%
  mutate(volume = width * height * depth)
```


```{r, solution = TRUE}
excel_sheets(xls_file) %>%
  set_names() %>% 
  map_df(read_excel, path = xls_file, .id = "treatment_onset", range = "B3:C9") %>% 
  mutate(tidy_size = stringr::str_split(size, "x") %>% map(parse_integer),
         volume = map_dbl(tidy_size, reduce, `*`))
```
